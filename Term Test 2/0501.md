Below are concise, clear explanations for each answer in Term Test 2 (CSC 209 H1S).

---

## Question 1

**(a)** A process becomes an **orphan** if its parent exits before it does. The system’s `init` process (PID 1) then adopts the orphan. When the orphan finally terminates, `init` calls `wait` to collect its exit status and prevent it from lingering as a zombie.

**(b)** Given a function pointer `fp` assigned to `malloc`, the only correct call is:

```c
char *str = fp(size);
```

All other forms (using `*fp(size)`, `&fp(size)`, or `fp(*size)`) are invalid.

**(c)** Header files share prototypes, macros, and type definitions. They do not speed up execution by pre-compiling code.

**(d)** The safe, fully parenthesized macro is:

```c
#define ADJUST(x) ((x) + 2)
```

---

## Question 2

**(a)** The program forks into two processes. The child sets `p[0] = 'B'` and the parent sets `p[0] = 'C'`. Both then run `execlp("echo", "echo", p, NULL)`, so the output is:

```
B
C
```

The subsequent `printf("D")` is never reached.

**(b)** To compile without linking (avoiding undefined-reference errors), use either:

```
gcc -Wall -g -c code.c
gcc -c code.c
```

Linking commands (without `-c`) will fail because `f` is declared but not defined.

---

## Question 3

A `Makefile` defines targets `all` (default), `calc`, and rules for object files.

**(a)** `make matrix_ops.o` generates `matrix_ops.o`.

**(b)** `make calc` then compiles `main.c` and `math_ops.c` (creating `main.o`, `math_ops.o`) and links them with `matrix_ops.o` to produce `calc`.

**(c)** Running `make` by itself builds the first target, `all`, which depends on `calc`.

**(d)** A pattern rule `%.o: %.c` compiles `.c` to `.o` but omits header dependencies, so changes in headers won’t trigger recompilation of affected objects.

---

## Question 4

The program has nested `fork()` calls.

**(a)** Four processes are created in total (the original plus three new ones).

**(b)** `E` and `D` cannot appear first: `E` prints only after a `wait`, and `D` is printed at each process’s end, after other letters.

**(c) True/False:**

- All characters print before returning to the shell. **False**
    
- At least one character prints more than once. **True**
    
- `B` can print last. **True**
    
- `D` cannot print before `C`. **True**
    

---

## Question 5

To replace the kᵗʰ element in a binary file that starts with an `int` length followed by an array of `struct data`:

```c
int replace_data(char *filename, int k, struct data new_data) {
    FILE *fp = fopen(filename, "rb+");
    int len;                     
    fread(&len, sizeof(int), 1, fp);
    if (k < 0 || k >= len) {
        fclose(fp);
        return -1;
    }
    fseek(fp, sizeof(int) + k * sizeof(struct data), SEEK_SET);
    fwrite(&new_data, sizeof(struct data), 1, fp);
    fclose(fp);
    return 0;
}
```

Steps:

1. Open file in `rb+` mode.
    
2. Read the array length.
    
3. Verify `k` is within bounds.
    
4. Seek past the length and `(k)` elements.
    
5. Overwrite the kᵗʰ item with `new_data` and close the file.
    

---
